{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE LambdaCase #-}

module Main where

import Data.Semigroup ((<>))
import GHC.Generics (Generic)
import System.IO (hFlush, stdout)

import Data.Csv (FromRecord, HasHeader (HasHeader), decode)
import qualified Data.Vector as V (foldl', head, map, null, tail)
import Data.Vector (Vector)
import Distribution.ModuleName (fromString, toFilePath)
import Network.HTTP.Simple (getResponseBody, httpLBS, parseRequest)
import Options.Applicative (Parser, (<**>), execParser, fullDesc, header, help,
  helper, info, long, metavar, progDesc, showDefault, strOption, value)
import System.Directory (createDirectoryIfMissing, doesFileExist)
import System.FilePath ((</>), (<.>), takeDirectory)

data SicRecord = SicRecord
  { sicCode        :: Int
  , sicDescription :: String
  } deriving (Generic, Show)

instance FromRecord SicRecord

data Options = Options
  { uri        :: String
  , copyright  :: String
  , licence    :: String
  , sourceDir  :: FilePath
  , moduleName :: String
  }

program :: Parser Options
program = Options
  <$> strOption
      ( long "uri"
     <> metavar "URI"
     <> value defUri
     <> showDefault
     <> help "Location of .csv file to process" )
  <*> strOption
      ( long "copyright"
     <> metavar "TEXT"
     <> value defCopyright
     <> showDefault
     <> help "Copyright notice applicable to .csv file" )
  <*> strOption
     ( long "licence"
    <> metavar "TEXT"
    <> value defLicence
    <> showDefault
    <> help "Licence applicable to .csv file" )
 <*> strOption
      ( long "source-dir"
     <> metavar "DIRECTORY"
     <> value "src"
     <> showDefault
     <> help "Location of generated module" )
  <*> strOption
      ( long "module"
     <> metavar "MODULE"
     <> value "Data.Sic.UkSic2007"
     <> showDefault
     <> help "Module name" )

-- |As at 9 April 2018, published by the UK Government (Crown Copyright) under
-- the Open Government Licence v3.0.
defUri :: String
defUri = "https://www.gov.uk/government/uploads/system/uploads\
         \/attachment_data/file/527619/SIC07_CH_condensed_list_en.csv"
defCopyright :: String
defCopyright = "Crown Copyright"
defLicence :: String
defLicence = "Contains public sector information licensed under the Open \
             \Government Licence v3.0. <https://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/>"

main :: IO ()
main = main' =<< execParser opts
 where
  opts = info (program <**> helper)
    ( fullDesc
   <> progDesc "Process a CSV file identified by a URI to produce a Haskell \
               \module located under a specified source directory. The module \
               \can include copyright and licence information."
   <> header "uksic2007 - generate Haskell module from CSV file" )

main' :: Options -> IO ()
main' opts = do
  let uri' = uri opts
      copyright' = copyright opts
      licence' = licence opts
      sourceDir' = sourceDir opts
      moduleName' = moduleName opts
      moduleFilePath' = moduleFilePath sourceDir' moduleName'
  putStrLn $ "Using " ++ uri' ++ " to produce " ++ moduleName' ++ " at " ++
    moduleFilePath'
  doesFileExist moduleFilePath' >>= \case
    False -> return ()
    True  -> putStrLn "Processing will overwrite an existing file."
  yesno "Process" >>= \case
    False -> putStrLn "Exited without processing."
    True  -> process uri' copyright' licence' moduleName' moduleFilePath'

moduleFilePath :: FilePath -> String -> FilePath
moduleFilePath sourceDir moduleName = sourceDir </>
  toFilePath (fromString moduleName) <.> "hs"

process :: String -> String -> String -> String -> String -> IO ()
process uri copyright licence moduleName filePath = case parseRequest uri of
  Just sicUri -> do
    r <- httpLBS sicUri
    let bs = getResponseBody r
        mcsv = decode HasHeader bs
    either putStrLn process' mcsv
    putStrLn "Processed."
  Nothing -> putStrLn $ uri ++ " could not be understood as a URL."
 where
  process' list = do
    createDirectoryIfMissing True (takeDirectory filePath)
    writeFile filePath (makeModule list uri moduleName copyright licence)

makeModule :: Vector SicRecord
           -> String            -- URI
           -> String            -- module name
           -> String            -- copywrite
           -> String            -- licence
           -> String
makeModule list uri moduleName copyright licence =
  "{-|\n\
  \Module      : " ++ moduleName ++ "\n\
  \Description : Automatically generated by application uksic2007 from file:\n" ++
  "              " ++ uri ++ "\n" ++
  if null copyright then "" else ("Copyright   : " ++ copyright ++ "\n") ++
  if null licence   then "" else ("Licence     : " ++ licence ++ "\n") ++
  "-}\n\
  \\n\
  \{-# LANGUAGE OverloadedStrings #-}\n\
  \\n\
  \module " ++ moduleName ++ "\n\
  \  ( UkSic2007 (UkSic2007)\n\
  \  , ukSic2007\n\
  \  ) where\n\
  \\n\
  \import Data.Map.Strict (Map, fromList)\n\
  \import Data.Text (Text)\n\
  \\n\
  \newtype UkSic2007 = UkSic2007 Int deriving (Eq, Show)\n\
  \\n\
  \ukSic2007 :: Map Int Text\n\
  \ukSic2007 = fromList\n" ++
  pplist
 where
  pplist
    | V.null list = whitespace ++ "[]\n"
    | otherwise = V.foldl' (++) (whitespace ++ "[ " ++ pp sr1 ++ "\n")
        (V.map (\sr -> whitespace ++ ", " ++ pp sr ++ "\n") rest) ++
        whitespace ++ "]\n"
  whitespace = replicate 2 ' '
  sr1 = V.head list
  rest = V.tail list
  pp (SicRecord sic desc) = "(" ++ show sic ++ ", " ++ show desc ++ ")"

yesno :: String -> IO Bool
yesno question = loop
 where
  loop = do
    putStr $ question ++ " (Y/N)? "
    hFlush stdout
    getChar >>= \case
      'Y' -> return True
      'y' -> return True
      'N' -> return False
      'n' -> return False
      _   -> loop
